# Generated by ChatGPT4 2023-06-20

# Import necessary libraries
import tkinter as tk  # used for creating the graphical user interface (GUI)
from tkinter import messagebox  # used for displaying messages to the user
import time  # used for controlling the timing of the program
import json  # used for encoding and decoding JSON data
import socket  # used for creating a network connection
import threading  # used for running multiple tasks at the same time
import atexit

class DeoVRClient:
    def __init__(self, gui, id, host='10.0.0.60', port=23554):
        # The constructor takes a gui object, a host address and a port number.
        # The gui object will be used to interact with the GUI.
        # The host and port will be used to connect to the DeoVR app.

        self.gui = gui
        self.id = id
        self.host = host
        self.port = port
        self.sock = None
        self.connected = False
        self.receiver = None
        self.pinger = None

    def connect(self, hostname, port):
        # This method is called to connect to the DeoVR app.
        # A socket is created and connected to the specified host and port.
        # Two threads are started: one for receiving data from the app and one for pinging the app.
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            print(f"Attempting to connect to {hostname}:{port}")  # debug log
            self.sock.connect((hostname, port))
            print("Connected successfully")  # debug log
            self.connected = True
            self.send({})
            self.receiver = threading.Thread(target=self._receive)
            self.receiver.start()
            self.pinger = threading.Thread(target=self._start_ping)
            self.pinger.start()
        except Exception as e:
            print(f"Failed to connect due to: {e}")  # debug log
            self.connected = False

    def disconnect(self):
        # This method is called to disconnect from the DeoVR app.
        # The socket is closed and the receiver and pinger threads are stopped.

        self.connected = False
        if self.sock is not None:  # add this line
            self.sock.close()
        if self.receiver is not None:  # check if receiver thread exists before joining
            self.receiver.join()
        if self.pinger is not None:  # check if pinger thread exists before joining
            self.pinger.join()

    def stop(self):
        self.connected = False
        if self.sock is not None:
            self.sock.close()
        if self.receiver is not None and self.receiver.is_alive():
            self.receiver.join()
        if self.pinger is not None and self.pinger.is_alive():
            self.pinger.join()


    def send(self, data):
        # This method is called to send data to the DeoVR app.
        # The data is encoded as JSON and then sent over the socket.

        if data:
            msg = json.dumps(data).encode('utf-8')
            length = len(msg)
            try:
                if self.sock:
                    self.sock.sendall(length.to_bytes(4, 'little') + msg)
            except Exception as e:
                print(f"Exception while sending data: {e}")
                # If an error occurs, close the socket and reopen the connection
                self.disconnect()
                time.sleep(1)
                self.connect()
        else:  # Sending a ping
            self.sock.sendall((0).to_bytes(4, 'little'))

    def _receive(self):
        # This method is run in a separate thread and is responsible for receiving data from the DeoVR app.
        # When data is received, it is decoded and passed to the GUI to update the interface.

        while self.connected:
            try:
                length = int.from_bytes(self.sock.recv(4), 'big')
                if length:
                    msg = json.loads(self.sock.recv(length).decode('utf-8'))
                    self.gui.update(self.id, msg)
            except Exception as e:
                print(f"Exception in receive: {e}")
                break  # Break the loop and end the thread if an exception occurs


    def _start_ping(self):
        # This method is run in a separate thread and is responsible for pinging the DeoVR app every second.
        # This keeps the connection to the app alive.

        while self.connected:
            try:
                self.send(None)  # Sending a ping
                time.sleep(1)
            except Exception as e:
                print(f"Exception in ping: {e}")
                break


class DeoVRGui:
    def __init__(self):
        # Constructor: sets up the GUI window and elements, and creates a DeoVRClient for interacting with the DeoVR app.
        
        # Create main application window
        self.window = tk.Tk()
        self.window.title("DeoVR Remote Control")

        # Create two clients
        self.clients = [
            DeoVRClient(self, id=0),
            DeoVRClient(self, id=1)
        ]

        self.frames = []
        self.buttons_that_require_connection = []

        # Now that all the frames have been fully set up, disable the buttons
        self.setup()


    def connect_button_clicked(self, id):
        try:
            hostname = self.frames[id]['hostname_entry'].get()
            port = int(self.frames[id]['port_entry'].get())
            self.clients[id].connect(hostname, port)

            messagebox.showinfo("Connection status", f"Successfully connected to client {id+1}")
            # Enable the buttons when the connection is successful.
            self.set_buttons_state('normal', id)
        except Exception as e:
            messagebox.showerror("Connection status", f"Failed to connect to client {id+1}: {e}")

    def disconnect_button_clicked(self, id):
        try:
            self.clients[id].disconnect()
            messagebox.showinfo("Connection status", f"Successfully disconnected from client {id+1}")
            # Disable the buttons when the connection is closed.
            self.set_buttons_state('disabled', id)
        except Exception as e:
            messagebox.showerror("Connection status", f"Failed to disconnect from client {id+1}: {e}")

    def open_path_button_clicked(self, id):
        path = self.frames[id]['path_entry'].get()
        self.clients[id].send({"path": path})

    def play_button_clicked(self, id):
        self.clients[id].send({"playerState": 0})

    def pause_button_clicked(self, id):
        self.clients[id].send({"playerState": 1})

    def seek_button_clicked(self, id):  # new method
        seek_time = float(self.frames[id]['seek_entry'].get())  # we convert the input to float, as it's time in seconds
        self.clients[id].send({"currentTime": seek_time})

    def set_playback_speed_button_clicked(self, id):
        playback_speed = float(self.frames[id]['playback_speed_entry'].get())  # we convert the input to float, as it's speed
        self.clients[id].send({"playbackSpeed": playback_speed})

    def update(self, id, data):
        print(f'Received data from client {id}: {data}')  # This will log the data received.
        # Update GUI with received data
        player_state = "Playing" if data['playerState'] == 0 else "Paused"
        self.frames[id]['player_status']["text"] = f"Player Status: {player_state}"

        if "currentTime" in data:
            self.frames[id]['current_time_label'].config(text=f"Current Time: {data['currentTime']}")  # new

        if "duration" in data:
            self.frames[id]['duration_label'].config(text=f"Duration: {data['duration']}")  # new

        if "playbackSpeed" in data:
            self.frames[id]['playback_speed_label'].config(text=f"Playback Speed: {data['playbackSpeed']}") # new

    def stop_all_clients(self):
        for client in self.clients:
            client.stop()

    def run(self):
        self.window.mainloop()

    def create_widgets_for_client(self, frame, id):
        widgets = {}

        widgets['hostname_entry'] = tk.Entry(frame)
        widgets['hostname_entry'].grid(row=0, column=1)
        widgets['hostname_entry'].insert(0, '10.0.0.60')  # pre-fill with the default hostname

        widgets['port_entry'] = tk.Entry(frame)
        widgets['port_entry'].grid(row=1, column=1)
        widgets['port_entry'].insert(0, '23554')  # pre-fill with the default port

        widgets['path_entry'] = tk.Entry(frame)
        widgets['path_entry'].grid(row=3, column=1)

        widgets['connect_button'] = tk.Button(frame, text="Connect", command=lambda: self.connect_button_clicked(id))
        widgets['connect_button'].grid(row=2, column=0, columnspan=2)

        widgets['disconnect_button'] = tk.Button(frame, text="Disconnect", command=lambda: self.disconnect_button_clicked(id))
        widgets['disconnect_button'].grid(row=2, column=2, columnspan=2)

        widgets['open_path_button'] = tk.Button(frame, text="Open Path", command=lambda: self.open_path_button_clicked(id))
        widgets['open_path_button'].grid(row=4, column=0, columnspan=2)

        widgets['play_button'] = tk.Button(frame, text="Play", command=lambda: self.play_button_clicked(id))
        widgets['play_button'].grid(row=5, column=0)

        widgets['pause_button'] = tk.Button(frame, text="Pause", command=lambda: self.pause_button_clicked(id))
        widgets['pause_button'].grid(row=5, column=1)

        widgets['buttons_that_require_connection'] = [
            widgets['open_path_button'],
            widgets['play_button'],
            widgets['pause_button'],
        ]

        return widgets

    def create_frame(self, id, client):
        frame = tk.Frame(self.window)
        frame.grid(row=0, column=id)

        # Create "Connect" button and define what happens when it is clicked
        connect_button = tk.Button(frame, text=f"Connect {id+1}", command=lambda: self.connect_button_clicked(id))
        connect_button.pack()

        # Create "Disconnect" button and define what happens when it is clicked
        disconnect_button = tk.Button(frame, text=f"Disconnect {id+1}", command=lambda: self.disconnect_button_clicked(id))
        disconnect_button.pack()

        # Create and pack labels and entry fields for entering the hostname and port
        host_label = tk.Label(frame, text="Hostname:")
        host_label.pack()
        hostname_entry = tk.Entry(frame)
        hostname_entry.insert(0, '10.0.0.60')  # pre-fill with the default hostname
        hostname_entry.pack()

        port_label = tk.Label(frame, text="Port:")
        port_label.pack()
        port_entry = tk.Entry(frame)
        port_entry.insert(0, '23554')  # pre-fill with the default port
        port_entry.pack()

        # Create "Open Path" button and define what happens when it is clicked
        open_path_button = tk.Button(frame, text="Open Path", command=lambda: self.open_path_button_clicked(id))
        open_path_button.pack()

        # Create "Play" and "Pause" buttons and define what happens when they are clicked
        play_button = tk.Button(frame, text="Play", command=lambda: self.play_button_clicked(id))
        play_button.pack()
        pause_button = tk.Button(frame, text="Pause", command=lambda: self.pause_button_clicked(id))
        pause_button.pack()

        # Create label to display player status
        player_status = tk.Label(frame, text="Player Status: Not Connected")
        player_status.pack()

        # Create labels to display the current time and duration of the video
        current_time_label = tk.Label(frame, text="Current Time: 0.0")
        current_time_label.pack()
        duration_label = tk.Label(frame, text="Duration: 0.0")
        duration_label.pack()

        # Create and pack label, entry field and button for the seek functionality
        seek_label = tk.Label(frame, text="Seek to (in seconds):")
        seek_label.pack()
        seek_entry = tk.Entry(frame)
        seek_entry.pack()
        seek_button = tk.Button(frame, text="Seek", command=lambda: self.seek_button_clicked(id))
        seek_button.pack()

        # Create and pack label, entry field and button for the playback speed functionality
        playback_speed_label = tk.Label(frame, text="Playback speed:")
        playback_speed_label.pack()
        playback_speed_entry = tk.Entry(frame)
        playback_speed_entry.pack()
        set_playback_speed_button = tk.Button(frame, text="Set Playback Speed", command=lambda: self.set_playback_speed_button_clicked(id))
        set_playback_speed_button.pack()

        # Return the frame dictionary with all the GUI elements
        return {
            'frame': frame,
            'connect_button': connect_button,
            'disconnect_button': disconnect_button,
            'hostname_entry': hostname_entry,
            'port_entry': port_entry,
            'open_path_button': open_path_button,
            'play_button': play_button,
            'pause_button': pause_button,
            'player_status': player_status,
            'current_time_label': current_time_label,
            'duration_label': duration_label,
            'playback_speed_label': playback_speed_label,
            'seek_entry': seek_entry,
            'seek_button': seek_button,
            'playback_speed_entry': playback_speed_entry,
            'set_playback_speed_button': set_playback_speed_button,
            'buttons_that_require_connection': [
                open_path_button,
                play_button,
                pause_button,
                seek_button,
                set_playback_speed_button
            ],
        }

    def setup(self):
        # Add master control frame first
        master_control_frame = tk.Frame(self.window)
        master_control_frame.grid(row=0, column=0)  # Place it before all clients

        # Create master play pause buttons
        master_play_button = tk.Button(master_control_frame, text="Play All", command=self.master_play_button_clicked)
        master_play_button.pack()
        master_pause_button = tk.Button(master_control_frame, text="Pause All", command=self.master_pause_button_clicked)
        master_pause_button.pack()

        # Create master seek
        master_seek_label = tk.Label(master_control_frame, text="Seek to (in seconds):")
        master_seek_label.pack()
        self.master_seek_entry = tk.Entry(master_control_frame)
        self.master_seek_entry.pack()
        master_seek_button = tk.Button(master_control_frame, text="Seek All", command=self.master_seek_button_clicked)
        master_seek_button.pack()

        # Create master playback speed
        master_playback_speed_label = tk.Label(master_control_frame, text="Set Playback Speed to:")
        master_playback_speed_label.pack()
        self.master_playback_speed_entry = tk.Entry(master_control_frame)
        self.master_playback_speed_entry.pack()
        master_set_playback_speed_button = tk.Button(master_control_frame, text="Set Playback Speed All", command=self.master_set_playback_speed_button_clicked)
        master_set_playback_speed_button.pack()

        # Setip individual client frames
        for i, client in enumerate(self.clients):
            frame_dict = self.create_frame(i, client)
            self.frames.append(frame_dict)
            frame_dict['frame'].grid(row=0, column=i+1)  # Note that the column is i+1 now

            
    def master_play_button_clicked(self):
        for client in self.clients:
            client.send({"playerState": 0})

    def master_pause_button_clicked(self):
        for client in self.clients:
            client.send({"playerState": 1})

    def master_seek_button_clicked(self):
        seek_time = float(self.master_seek_entry.get())  # we convert the input to float, as it's time in seconds
        for client in self.clients:
            client.send({"currentTime": seek_time})

    def master_set_playback_speed_button_clicked(self):
        playback_speed = float(self.master_playback_speed_entry.get())  # we convert the input to float, as it's speed
        for client in self.clients:
            client.send({"playbackSpeed": playback_speed})
    
    def set_buttons_state(self, state, id):
        """
        Set the state of all buttons that require a connection.

        :param state: The state to set. Should be either 'normal' or 'disabled'.
        :param id: The id of the client for which the buttons should be set.
        """
        frame = self.frames[id]
        for button in frame['buttons_that_require_connection']:
            button.config(state=state)



if __name__ == "__main__":
    gui = DeoVRGui()
    atexit.register(gui.stop_all_clients)  # ensure stop is called when the program exits
    gui.run()