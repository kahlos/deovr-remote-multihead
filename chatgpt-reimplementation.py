# Generated by ChatGPT4 2023-06-20

# Import necessary libraries
import tkinter as tk  # used for creating the graphical user interface (GUI)
from tkinter import messagebox  # used for displaying messages to the user
import time  # used for controlling the timing of the program
import json  # used for encoding and decoding JSON data
import socket  # used for creating a network connection
import threading  # used for running multiple tasks at the same time
import atexit
import math
from threading import Thread

class DeoVRClient:
    def __init__(self, gui, id, host='10.0.0.60', port=23554):
        # The constructor takes a gui object, a host address and a port number.
        # The gui object will be used to interact with the GUI.
        # The host and port will be used to connect to the DeoVR app.

        self.gui = gui
        self.id = id
        self.host = host
        self.port = port
        self.sock = None
        self.connected = False
        self.receiver = None
        self.pinger = None
        self.sync_thread = None
        self.current_time = 0
        self.playback_speed = 1
        self.syncing = True  # Add this line

    def connect(self, hostname, port):
        # This method is called to connect to the DeoVR app.
        # A socket is created and connected to the specified host and port.
        # Two threads are started: one for receiving data from the app and one for pinging the app.
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            print(f"Attempting to connect to {hostname}:{port}")  # debug log
            self.sock.connect((hostname, port))
            print("Connected successfully")  # debug log
            self.connected = True
            self.send({})
            self.receiver = threading.Thread(target=self._receive)
            self.receiver.start()
            self.pinger = threading.Thread(target=self._start_ping)
            self.pinger.start()
            return True
        except Exception as e:
            print(f"Failed to connect due to: {e}")  # debug log
            self.connected = False
            return False

    def disconnect(self):
        # This method is called to disconnect from the DeoVR app.
        # The socket is closed and the receiver and pinger threads are stopped.

        self.connected = False
        self.syncing = False  # Add this line
        if self.sock is not None:  # add this line
            self.sock.close()
        if self.receiver is not None:  # check if receiver thread exists before joining
            self.receiver.join()
        if self.pinger is not None:  # check if pinger thread exists before joining
            self.pinger.join()
        if self.sync_thread is not None and self.sync_thread.is_alive():  # check if sync_thread exists before joining
            self.sync_thread.join()

    def stop(self):
        self.connected = False
        if self.sock is not None:
            self.sock.close()
        if self.receiver is not None and self.receiver.is_alive():
            self.receiver.join()
        if self.pinger is not None and self.pinger.is_alive():
            self.pinger.join()
        self.syncing = False  # Add this line


    def send(self, data):
        # This method is called to send data to the DeoVR app.
        # The data is encoded as JSON and then sent over the socket.

        if data:
            msg = json.dumps(data).encode('utf-8')
            length = len(msg)
            try:
                if self.sock:
                    self.sock.sendall(length.to_bytes(4, 'little') + msg)
            except Exception as e:
                print(f"Exception while sending data: {e}")
                # If an error occurs, close the socket and reopen the connection
                self.disconnect()
        else:  # Sending a ping
            try:
                self.sock.sendall((0).to_bytes(4, 'little'))
            except Exception as e:
                print(f"Exception while sending ping: {e}")
                # If an error occurs, close the socket
                self.disconnect()

    def _receive(self):
        # This method is run in a separate thread and is responsible for receiving data from the DeoVR app.
        # When data is received, it is decoded and passed to the GUI to update the interface.
        while self.connected:
            try:
                length_bytes = self.sock.recv(4)
                if length_bytes:
                    length = int.from_bytes(length_bytes, 'little')
                    msg_bytes = self.sock.recv(length)
                    try:
                        msg = json.loads(msg_bytes.decode('utf-8'))
                        self.gui.update(self.id, msg)
                        if 'currentTime' in msg:
                            self.current_time = msg['currentTime']
                            # print(f"[DEBUG] Current time for client {self.id}: {self.current_time}")  # New logging statement
                    except UnicodeDecodeError:
                        print(f"Failed to decode message from client {self.id}: {msg_bytes}")
            except Exception as e:
                print(f"Exception in receive: {e}")
                break  # Break the loop and end the thread if an exception occurs


    def _start_ping(self):
        # This method is run in a separate thread and is responsible for pinging the DeoVR app every second.
        # This keeps the connection to the app alive.

        while self.connected:
            try:
                self.send(None)  # Sending a ping
                time.sleep(1)
            except Exception as e:
                print(f"Exception in ping: {e}")
                break

    def _sync_loop(self):
        print(f"Starting syncronisation for headset #{self.id}")
        sync_checks = 0  # Counter for number of sync checks within tolerance

        try:
            while self.syncing:
                # print(f"[DEBUG] Sync loop for client {self.id} is running.")  # New logging statement
                master = self.gui.clients[0]  # Assume the first client is the master
                
                if master.connected and self.connected:  # Only sync if both the master and this client are connected
                    # Refresh master time by setting playback speed
                    master.send({"playbackSpeed": 1.0})

                    # Calculate time difference between master and this client
                    # print(f"[DEBUG] Syncing client {self.id}. Master time: {master.current_time}, client time: {self.current_time}")  # New logging statement
                    time_difference = self.current_time - master.current_time

                     # If the time difference is less than 20 ms stop
                    if abs(time_difference) < 0.02:
                        sync_checks += 1
                        # print(f"[DEBUG] Sync check count {sync_checks}")
                        if sync_checks >=5:
                            self.send({"playbackSpeed": 1.0})
                            self.syncing = False  # Stop the sync loop
                            print(f"Syncronisation is finished for headset #{self.id}")
                    else:
                        sync_checks = 0  # Reset sync check counter if we're not within tolerance

                    if not self.syncing:
                        continue

                    # Set playback speed based on time difference
                    # Scale the adjustment based on the time difference. Max adjustment is 100%, min adjustment is 0.0001%
                    adjustment = min(max(abs(time_difference * time_difference * 10), 0.0001), 100) / 100
                    # print(f"[DEBUG] Time difference and adjustment for client {self.id}: {time_difference} / {adjustment}")  # New logging statement
                    if time_difference > 0:
                        if self.id != 0:  # Don't send playbackSpeed commands to the master
                            self.send({"playbackSpeed": max(0.25, 1 - adjustment)})  # If this client is ahead, slow it down
                    elif time_difference < 0:
                        if self.id != 0:  # Don't send playbackSpeed commands to the master
                            self.send({"playbackSpeed": min(2, 1 + adjustment)})  # If this client is behind, speed it up
                    else:
                        if self.id != 0:  # Don't send playbackSpeed commands to the master
                            self.send({"playbackSpeed": 1.0})  # If the difference is 0, set the speed to normal

                time.sleep(0.1)  # Sleep for 100 ms before checking again
        except Exception as e:
            print(f"[ERROR] Exception in sync loop for client {self.id}: {e}")

    
    def start_sync_loop(self):
        self.syncing = True
        self.sync_thread = Thread(target=self._sync_loop)  # Recreate the thread
        self.sync_thread.start()

    def stop_sync_loop(self):
        self.syncing = False
        if self.sync_thread is not None:
            self.sync_thread.join()  # Wait for the thread to finish
            if self.sync_thread.is_alive():
                print(f"Sync thread for client {self.id} failed to stop.")
            # else:
                # print(f"Sync thread for client {self.id} stopped successfully.")
            self.sync_thread = None  # Reset the thread


class DeoVRGui:
    def __init__(self):
        # Constructor: sets up the GUI window and elements, and creates a DeoVRClient for interacting with the DeoVR app.
        
        # Create main application window
        self.window = tk.Tk()
        self.window.resizable(True, True)
        self.window.title("DeoVR Multi-Headset Control")

        # Create master control window
        self.master_window = tk.Toplevel(self.window)
        self.master_window.title("DeoVR Master Controls")

        # Variables for frame selector
        self.frame_num_var = tk.StringVar()
        self.frame_num_var.set("1")  # default value

        # Create a frame to contain all other frames (master and client frames)
        self.parent_frame = tk.Frame(self.window)
        self.parent_frame.pack()

        # Create placeholders for clients, frames and buttons
        self.clients = []
        self.frames = []
        self.buttons_that_require_connection = []

        # Create a frame container to hold all client frames
        self.parent_frame = tk.Frame(self.window)
        self.parent_frame.pack(fill=tk.BOTH, expand=True)

        # Now that all the frames have been fully set up, disable the buttons
        self.setup()


    def connect_button_clicked(self, id):
        hostname = self.frames[id]['hostname_entry'].get()
        port = int(self.frames[id]['port_entry'].get())
        connection_success = self.clients[id].connect(hostname, port)  # Try to connect and store the return value

        if connection_success:  # If the connection was successful
            messagebox.showinfo("Connection status", f"Successfully connected to client {id+1}")
            # Enable the buttons when the connection is successful.
            self.set_buttons_state('normal', id)
        else:  # If the connection failed
            messagebox.showerror("Connection status", f"Failed to connect to client {id+1}")

    def disconnect_button_clicked(self, id):
        try:
            self.clients[id].disconnect()
            messagebox.showinfo("Connection status", f"Successfully disconnected from client {id+1}")
            # Disable the buttons when the connection is closed.
            self.set_buttons_state('disabled', id)
        except Exception as e:
            messagebox.showerror("Connection status", f"Failed to disconnect from client {id+1}: {e}")

    def open_path_button_clicked(self, id):
        path = self.frames[id]['path_entry'].get()
        self.clients[id].send({"path": path})

    def play_button_clicked(self, id):
        self.clients[id].send({"playerState": 0})

    def pause_button_clicked(self, id):
        self.clients[id].send({"playerState": 1})

    def seek_button_clicked(self, id):  # new method
        seek_time = float(self.frames[id]['seek_entry'].get())  # we convert the input to float, as it's time in seconds
        self.clients[id].send({"currentTime": seek_time})

    def set_playback_speed_button_clicked(self, id):
        playback_speed = float(self.frames[id]['playback_speed_entry'].get())  # we convert the input to float, as it's speed
        self.clients[id].send({"playbackSpeed": playback_speed})

    def update(self, id, data):
        # print(f'Received data from client {id}: {data}')  # This will log the data received.
        # Update GUI with received data
        player_state = "Playing" if data['playerState'] == 0 else "Paused"
        self.frames[id]['player_status']["text"] = f"Player Status: {player_state}"

        if "currentTime" in data:
            self.frames[id]['current_time_label'].config(text=f"Current Time: {data['currentTime']}")  # new

        if "duration" in data:
            self.frames[id]['duration_label'].config(text=f"Duration: {data['duration']}")  # new

        if "playbackSpeed" in data:
            self.frames[id]['playback_speed_label'].config(text=f"Playback Speed: {data['playbackSpeed']}") # new

    def stop_all_clients(self):
        for client in self.clients:
            client.stop()

    def run(self):
        try:
            self.window.mainloop()
        finally:
            self.syncing = False  # add this line
            for client in self.clients:
                client.stop_sync_loop()  # Ensure all sync loops are stopped

    def create_widgets_for_client(self, frame, id):
        widgets = {}

        widgets['hostname_entry'] = tk.Entry(frame)
        widgets['hostname_entry'].grid(row=0, column=1)
        widgets['hostname_entry'].insert(0, '10.0.0.60')  # pre-fill with the default hostname

        widgets['port_entry'] = tk.Entry(frame)
        widgets['port_entry'].grid(row=1, column=1)
        widgets['port_entry'].insert(0, '23554')  # pre-fill with the default port

        widgets['path_entry'] = tk.Entry(frame)
        widgets['path_entry'].grid(row=3, column=1)

        widgets['connect_button'] = tk.Button(frame, text="Connect", command=lambda: self.connect_button_clicked(id))
        widgets['connect_button'].grid(row=2, column=0, columnspan=2)

        widgets['disconnect_button'] = tk.Button(frame, text="Disconnect", command=lambda: self.disconnect_button_clicked(id))
        widgets['disconnect_button'].grid(row=2, column=2, columnspan=2)

        widgets['open_path_button'] = tk.Button(frame, text="Open Path", command=lambda: self.open_path_button_clicked(id))
        widgets['open_path_button'].grid(row=4, column=0, columnspan=2)

        widgets['play_button'] = tk.Button(frame, text="Play", command=lambda: self.play_button_clicked(id))
        widgets['play_button'].grid(row=5, column=0)

        widgets['pause_button'] = tk.Button(frame, text="Pause", command=lambda: self.pause_button_clicked(id))
        widgets['pause_button'].grid(row=5, column=1)

        widgets['buttons_that_require_connection'] = [
            widgets['open_path_button'],
            widgets['play_button'],
            widgets['pause_button'],
        ]

        return widgets

    def create_frame(self, id, client):
        frame = tk.Frame(self.parent_frame)  # note the parent widget here
        frame.grid(row=0, column=id)

        # Create "Connect" button and define what happens when it is clicked
        connect_button = tk.Button(frame, text=f"Connect {id+1}", command=lambda: self.connect_button_clicked(id))
        connect_button.pack()

        # Create "Disconnect" button and define what happens when it is clicked
        disconnect_button = tk.Button(frame, text=f"Disconnect {id+1}", command=lambda: self.disconnect_button_clicked(id))
        disconnect_button.pack()

        # Create and pack labels and entry fields for entering the hostname and port
        host_label = tk.Label(frame, text="Hostname:")
        host_label.pack()
        hostname_entry = tk.Entry(frame)
        hostname_entry.insert(0, '10.0.0.60')  # pre-fill with the default hostname
        hostname_entry.pack()

        port_label = tk.Label(frame, text="Port:")
        port_label.pack()
        port_entry = tk.Entry(frame)
        port_entry.insert(0, '23554')  # pre-fill with the default port
        port_entry.pack()

        # Create "Open Path" button and define what happens when it is clicked
        path_label = tk.Label(frame, text="Video Path:")
        path_label.pack()
        path_entry = tk.Entry(frame)
        path_entry.pack()
        path_entry.insert(0, '/storage/emulated/0/Movies/')  # pre-fill with the video folder
        open_path_button = tk.Button(frame, text="Open Path", command=lambda: self.open_path_button_clicked(id, path_entry.get()))
        open_path_button.pack()

        # Create "Play" and "Pause" buttons and define what happens when they are clicked
        play_button = tk.Button(frame, text="Play", command=lambda: self.play_button_clicked(id))
        play_button.pack()
        pause_button = tk.Button(frame, text="Pause", command=lambda: self.pause_button_clicked(id))
        pause_button.pack()

        # Create label to display player status
        player_status = tk.Label(frame, text="Player Status: Not Connected")
        player_status.pack()

        # Create labels to display the current time and duration of the video
        current_time_label = tk.Label(frame, text="Current Time: 0.0")
        current_time_label.pack()
        duration_label = tk.Label(frame, text="Duration: 0.0")
        duration_label.pack()

        # Create and pack label, entry field and button for the seek functionality
        seek_label = tk.Label(frame, text="Seek to (in seconds):")
        seek_label.pack()
        seek_entry = tk.Entry(frame)
        seek_entry.pack()
        seek_button = tk.Button(frame, text="Seek", command=lambda: self.seek_button_clicked(id))
        seek_button.pack()

        # Create and pack label, entry field and button for the playback speed functionality
        playback_speed_label = tk.Label(frame, text="Playback speed:")
        playback_speed_label.pack()
        playback_speed_entry = tk.Entry(frame)
        playback_speed_entry.pack()
        set_playback_speed_button = tk.Button(frame, text="Set Playback Speed", command=lambda: self.set_playback_speed_button_clicked(id))
        set_playback_speed_button.pack()

        # Return the frame dictionary with all the GUI elements
        return {
            'frame': frame,
            'connect_button': connect_button,
            'disconnect_button': disconnect_button,
            'hostname_entry': hostname_entry,
            'port_entry': port_entry,
            'path_label': path_label,
            'path_entry': path_entry,
            'open_path_button': open_path_button,
            'play_button': play_button,
            'pause_button': pause_button,
            'player_status': player_status,
            'current_time_label': current_time_label,
            'duration_label': duration_label,
            'playback_speed_label': playback_speed_label,
            'seek_entry': seek_entry,
            'seek_button': seek_button,
            'playback_speed_entry': playback_speed_entry,
            'set_playback_speed_button': set_playback_speed_button,
            'buttons_that_require_connection': [
                open_path_button,
                play_button,
                pause_button,
                seek_button,
                set_playback_speed_button
            ],
        }

    def setup(self):
        # Add master control frame first
        master_control_frame = tk.Frame(self.master_window)
        master_control_frame.grid(row=0, column=0)  # Place it before all clients

        # Create master play pause buttons
        master_play_button = tk.Button(master_control_frame, text="Play All", command=self.master_play_button_clicked)
        master_play_button.pack()
        master_pause_button = tk.Button(master_control_frame, text="Pause All", command=self.master_pause_button_clicked)
        master_pause_button.pack()

        # Create master seek
        master_seek_label = tk.Label(master_control_frame, text="Seek to (in seconds):")
        master_seek_label.pack()
        self.master_seek_entry = tk.Entry(master_control_frame)
        self.master_seek_entry.pack()
        master_seek_button = tk.Button(master_control_frame, text="Seek All", command=self.master_seek_button_clicked)
        master_seek_button.pack()

        # Create master playback speed
        master_playback_speed_label = tk.Label(master_control_frame, text="Set Playback Speed to:")
        master_playback_speed_label.pack()
        self.master_playback_speed_entry = tk.Entry(master_control_frame)
        self.master_playback_speed_entry.pack()
        master_set_playback_speed_button = tk.Button(master_control_frame, text="Set Playback Speed All", command=self.master_set_playback_speed_button_clicked)
        master_set_playback_speed_button.pack()

        # Create master path selector
        master_path_label = tk.Label(master_control_frame, text="Path:")
        master_path_label.pack()
        self.master_path_entry = tk.Entry(master_control_frame)
        self.master_path_entry.pack()
        self.master_path_entry.insert(0, '/storage/emulated/0/Movies/') # pre-fill with the video folder
        master_open_path_button = tk.Button(master_control_frame, text="Open Path", command=self.master_open_path_button_clicked)
        master_open_path_button.pack()

        # Add number of frames / headsets selector
        frame_num_label = tk.Label(master_control_frame, text="Number of headsets:")
        frame_num_label.pack(side="left")
        frame_num_entry = tk.Entry(master_control_frame, textvariable=self.frame_num_var)
        frame_num_entry.pack(side="left")
        frame_num_button = tk.Button(master_control_frame, text="Setup", command=self.setup)
        frame_num_button.pack(side="left")

        # Check the frame number input by user is valid
        try:
            num_frames = int(self.frame_num_var.get())
        except ValueError:
            messagebox.showerror("Error", "Invalid frame count. Please enter a number.")
            return

        # Clear current clients and frames
        self.clients.clear()
        for frame_dict in self.frames:
            frame_dict['frame'].destroy()
        self.frames.clear()

        # Calculate appropriate row and column for each frame
        num_frames = int(self.frame_num_var.get())
        num_columns = math.ceil(math.sqrt(num_frames))  # Determine the number of columns dynamically

        # Create new clients and frames
        for i in range(num_frames):
            client = DeoVRClient(self, id=i)
            self.clients.append(client)

            frame_dict = self.create_frame(i, client)
            self.frames.append(frame_dict)

        for i, frame_dict in enumerate(self.frames):
            row = (i // num_columns) + 1  # Add one to leave space for the master controls
            column = (i % num_columns) + 1  # Add one to leave space for the master controls
            frame_dict['frame'].grid(row=row, column=column, padx=10, pady=10)
            
    def master_play_button_clicked(self):
        print(f"Starting playback on all headsets")
        # Start playing on all clients
        self.clients[0].send({"playerState": 0})
        for client in self.clients:
            client.send({"playerState": 0})
        # After starting all clients, now we start the syncing loops
        for client in self.clients:
            client.stop_sync_loop()  # Stop any previous sync loop
            client.start_sync_loop()  # Start a new sync loop
            client.send({"playerState": 2})

    def master_pause_button_clicked(self):
        print(f"Pausing all headsets")
        self.clients[0].send({"playerState": 1})
        for client in self.clients:
            client.stop_sync_loop()  # Stop any previous sync loop
            client.send({"playerState": 1})

    def master_seek_button_clicked(self):
        seek_time = float(self.master_seek_entry.get())  # we convert the input to float, as it's time in seconds
        print(f"Seeking all headsets to {seek_time}")
        for client in self.clients:
            client.send({"currentTime": seek_time})

    def master_set_playback_speed_button_clicked(self):
        playback_speed = float(self.master_playback_speed_entry.get())  # we convert the input to float, as it's speed
        print(f"Setting playback speed for all headsets to {playback_speed}")
        for client in self.clients:
            client.send({"playbackSpeed": playback_speed})

    def master_open_path_button_clicked(self):
        path = self.master_path_entry.get()
        print(f"Opening on all headsets {path}")
        for client in self.clients:
            client.send({"path": path})
        
    def open_path_button_clicked(self, id, path):
        self.clients[id].send({"path": path})

    def set_buttons_state(self, state, id):
        """
        Set the state of all buttons that require a connection.

        :param state: The state to set. Should be either 'normal' or 'disabled'.
        :param id: The id of the client for which the buttons should be set.
        """
        frame = self.frames[id]
        for button in frame['buttons_that_require_connection']:
            button.config(state=state)



if __name__ == "__main__":
    gui = DeoVRGui()
    atexit.register(gui.stop_all_clients)  # ensure stop is called when the program exits
    gui.run()